
/*
 * This file was generated by the SOM Compiler.
 * FileName: scemit.xh.
 * Generated using:
 *     SOM Precompiler somipc: 2.29.1.17
 *     SOM Emitter emitxh: 2.47
 */

/*
 *   COMPONENT_NAME: some
 * 
 *   ORIGINS: 27
 * 
 * 
 *    25H7912  (C)  COPYRIGHT International Business Machines Corp. 1992,1994,1996
 *   All Rights Reserved
 *   Licensed Materials - Property of IBM
 *   US Government Users Restricted Rights - Use, duplication or
 *   disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 *  @(#) somc/sctypes.h 2.7 12/26/95 16:26:17 [7/30/96 14:46:04]
 * 
 */


#ifndef SOM_SOMTEmitC_xh
#define SOM_SOMTEmitC_xh

class SOMTEmitC;

/*
 *  This is the pluggable unit in the SOM emitter framework. An emitter
 *  is constructed by subclassing this class and then running the
 *  master emitter program providing the name of the subclass as one of
 *  its command line arguments.
 *  The concepts of this class are simple:
 * 
 *    Emitters always consist of a set of sections
 *    The sections are in a particular order for any particular
 *    emitter, and the order does not vary with the data processed by
 *    the emitter.
 *    A number of the sections of an emitter are common (maybe with
 *    slight variation) across several (or even most) emitters.
 *    There are a number of constructs that occur in varying numbers,
 *    eg, method declarations, data declarations, and attribute
 *    declarations.
 *  Consequently, this class provides methods for:
 *    Methods for many common sections, including several that may be
 *    useful without overridding in several different emitters
 *    Sequencing through the sections of the emitter
 *    Iterating through the constructs that occur in varying numbers
 */

#define SOMTEmitC_MajorVersion 2
#define SOMTEmitC_MinorVersion 1

/* C++ SOM defs */
#include <somcls.xh>
#include <somcm.xh>

/* C++ parent defs */
#ifndef SOM_SOMObject_xh
#include <somobj.xh>
#endif

#ifndef SOMTEmitC_API
#define SOMTEmitC_API
/*
 * -- The Class API
 */

/*
 * Start of bindings for IDL types
 */

class SOMClass;
class SOMObject;
class SOMStringTableC;
class SOMTEntryC;
class SOMTEmitC;
class SOMTMetaClassEntryC;
class SOMTAttributeEntryC;
class SOMTTypedefEntryC;
class SOMTBaseClassEntryC;
class SOMTPassthruEntryC;
class SOMTDataEntryC;
class SOMTMethodEntryC;
class SOMTClassEntryC;
class SOMTModuleEntryC;
class SOMTParameterEntryC;
class SOMTStructEntryC;
class SOMTUnionEntryC;
class SOMTEnumEntryC;
class SOMTConstEntryC;
class SOMTSequenceEntryC;
class SOMTStringEntryC;
class SOMTEnumNameEntryC;
class SOMTCommonEntryC;
class SOMTUserDefinedTypeEntryC;

/*
 * End of bindings for IDL types.
 */

/*
 * Passthru lines: File: "C.xh", "after"
 */
#include <sctypes.h>
#include <sctmplt.xh>
#include <scclass.xh>
#include <scmeta.xh>
#include <scmethod.xh>
#include <scpass.xh>
    /*
     * These macros provide short-hands for the use of the Scan
     * Methods.
     */

    #define SCAN_NOFILTER(scan,method) \
        _##scan(somSelf, #method"Prolog", #method, #method"Epilog")
    #define SCAN_NOFILTER_SN(scan,method,base,newbase) \
        {_somtSetSymbolCopyBoth(_t, #base"PrologSN", #newbase"PrologS"); \
        _somtSetSymbolCopyBoth(_t, #base"SN", #newbase"S"); \
        _somtSetSymbolCopyBoth(_t, #base"EpilogSN", #newbase"EpilogS"); \
        _##scan(somSelf, #method"Prolog", #method, #method"Epilog");}
    #define SCAN_FILTER(scan,filt,method) \
        _##scan(somSelf, #filt, #method"Prolog", #method, #method"Epilog",0)
    #define SCAN_FILTER_SN(scan,filt,method,base,newbase) \
        {_somtSetSymbolCopyBoth(_t, #base"PrologSN", #newbase"PrologS"); \
        _somtSetSymbolCopyBoth(_t, #base"SN", #newbase"S"); \
        _somtSetSymbolCopyBoth(_t, #base"EpilogSN", #newbase"EpilogS"); \
        _##scan(somSelf, #filt, #method"Prolog", #method, #method"Epilog",0);}

/* A procedure to create the SOMTEmitC Class */
SOMEXTERN SOMClass * SOMLINK SOMTEmitCNewClass(
		integer4 majorVersion,
		integer4 minorVersion);

/* The API to the SOMTEmitC class object, and the methods it introduces. */
SOMEXTERN struct SOMTEmitCClassDataStructure {
	SOMClass *classObject;
	somMToken _get_somtTemplate;
	somMToken _get_somtTargetFile;
	somMToken _set_somtTargetFile;
	somMToken _get_somtTargetClass;
	somMToken _set_somtTargetClass;
	somMToken _get_somtTargetModule;
	somMToken _set_somtTargetModule;
	somMToken _get_somtTargetType;
	somMToken _set_somtTargetType;
	somMToken somtGenerateSections;
	somMToken somtOpenSymbolsFile;
	somMToken somtSetPredefinedSymbols;
	somMToken somtFileSymbols;
	somMToken somtEmitProlog;
	somMToken somtEmitBaseIncludesProlog;
	somMToken somtEmitBaseIncludes;
	somMToken somtEmitBaseIncludesEpilog;
	somMToken somtEmitMetaInclude;
	somMToken somtEmitClass;
	somMToken somtEmitMeta;
	somMToken somtEmitBaseProlog;
	somMToken somtEmitBase;
	somMToken somtEmitBaseEpilog;
	somMToken somtEmitPassthruProlog;
	somMToken somtEmitPassthru;
	somMToken somtEmitPassthruEpilog;
	somMToken somtEmitRelease;
	somMToken somtEmitDataProlog;
	somMToken somtEmitData;
	somMToken somtEmitDataEpilog;
	somMToken somtEmitMethodsProlog;
	somMToken somtEmitMethods;
	somMToken somtEmitMethodsEpilog;
	somMToken somtEmitMethod;
	somMToken somtEmitEpilog;
	somMToken somtScanBases;
	somMToken somtScanConstants;
	somMToken somtCheckVisibility;
	somMToken somtNew;
	somMToken somtImplemented;
	somMToken somtOverridden;
	somMToken somtInherited;
	somMToken somtAllVisible;
	somMToken somtAll;
	somMToken somtNewNoProc;
	somMToken somtPrivOrPub;
	somMToken somtNewProc;
	somMToken somtLink;
	somMToken somtVA;
	somMToken somtScanMethods;
	somMToken somtScanData;
	somMToken somtScanPassthru;
	somMToken somtEmitFullPassthru;
	somMToken somtScanDataF;
	somMToken somtScanBasesF;
	somMToken _set_somtTemplate;
	somMToken _set_somtEmitterName;
	somMToken _get_somtEmitterName;
	somMToken somtEmitAttributeProlog;
	somMToken somtEmitAttribute;
	somMToken somtEmitAttributeEpilog;
	somMToken somtEmitConstantProlog;
	somMToken somtEmitConstant;
	somMToken somtEmitConstantEpilog;
	somMToken somtEmitTypedefProlog;
	somMToken somtEmitTypedef;
	somMToken somtEmitTypedefEpilog;
	somMToken somtEmitStructProlog;
	somMToken somtEmitStruct;
	somMToken somtEmitStructEpilog;
	somMToken somtEmitUnionProlog;
	somMToken somtEmitUnion;
	somMToken somtEmitUnionEpilog;
	somMToken somtEmitEnumProlog;
	somMToken somtEmitEnum;
	somMToken somtEmitEnumEpilog;
	somMToken somtEmitInterfaceProlog;
	somMToken somtEmitInterface;
	somMToken somtEmitInterfaceEpilog;
	somMToken somtEmitModuleProlog;
	somMToken somtEmitModule;
	somMToken somtEmitModuleEpilog;
	somMToken somtScanAttributes;
	somMToken somtScanTypedefs;
	somMToken somtScanStructs;
	somMToken somtScanUnions;
	somMToken somtScanEnums;
	somMToken somtScanInterfaces;
	somMToken somtScanModules;
	somMToken somtGetGlobalModifierValue;
	somMToken somtGetFirstGlobalDefinition;
	somMToken somtGetNextGlobalDefinition;
} SOMDLINK SOMTEmitCClassData;
#define _SOMTEmitC SOMTEmitCClassData.classObject

/* The API to parentMtabs for SOMTEmitC, and the instance data it introduces. */
SOMEXTERN struct SOMTEmitCCClassDataStructure {
	somMethodTabs parentMtab;
	somDToken              instanceDataToken;
} SOMDLINK SOMTEmitCCClassData;

/*
 * -- Typedefs for SOMTEmitC Method Procedures
 */
SOMEXTERN {
typedef SOMTTemplateOutputC*   SOMLINK somTP_SOMTEmitC__get_somtTemplate(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC__get_somtTemplate *somTD_SOMTEmitC__get_somtTemplate;
typedef void   SOMLINK somTP_SOMTEmitC__set_somtTemplate(SOMTEmitC *somSelf, 
		SOMTTemplateOutputC* somtTemplate);
typedef somTP_SOMTEmitC__set_somtTemplate *somTD_SOMTEmitC__set_somtTemplate;
typedef FILE*   SOMLINK somTP_SOMTEmitC__get_somtTargetFile(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC__get_somtTargetFile *somTD_SOMTEmitC__get_somtTargetFile;
typedef void   SOMLINK somTP_SOMTEmitC__set_somtTargetFile(SOMTEmitC *somSelf, 
		FILE* somtTargetFile);
typedef somTP_SOMTEmitC__set_somtTargetFile *somTD_SOMTEmitC__set_somtTargetFile;
typedef SOMTClassEntryC*   SOMLINK somTP_SOMTEmitC__get_somtTargetClass(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC__get_somtTargetClass *somTD_SOMTEmitC__get_somtTargetClass;
typedef void   SOMLINK somTP_SOMTEmitC__set_somtTargetClass(SOMTEmitC *somSelf, 
		SOMTClassEntryC* somtTargetClass);
typedef somTP_SOMTEmitC__set_somtTargetClass *somTD_SOMTEmitC__set_somtTargetClass;
typedef SOMTModuleEntryC*   SOMLINK somTP_SOMTEmitC__get_somtTargetModule(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC__get_somtTargetModule *somTD_SOMTEmitC__get_somtTargetModule;
typedef void   SOMLINK somTP_SOMTEmitC__set_somtTargetModule(SOMTEmitC *somSelf, 
		SOMTModuleEntryC* somtTargetModule);
typedef somTP_SOMTEmitC__set_somtTargetModule *somTD_SOMTEmitC__set_somtTargetModule;
typedef SOMTTargetTypeT   SOMLINK somTP_SOMTEmitC__get_somtTargetType(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC__get_somtTargetType *somTD_SOMTEmitC__get_somtTargetType;
typedef void   SOMLINK somTP_SOMTEmitC__set_somtTargetType(SOMTEmitC *somSelf, 
		SOMTTargetTypeT somtTargetType);
typedef somTP_SOMTEmitC__set_somtTargetType *somTD_SOMTEmitC__set_somtTargetType;
typedef string   SOMLINK somTP_SOMTEmitC__get_somtEmitterName(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC__get_somtEmitterName *somTD_SOMTEmitC__get_somtEmitterName;
typedef void   SOMLINK somTP_SOMTEmitC__set_somtEmitterName(SOMTEmitC *somSelf, 
		string somtEmitterName);
typedef somTP_SOMTEmitC__set_somtEmitterName *somTD_SOMTEmitC__set_somtEmitterName;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtGenerateSections(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtGenerateSections *somTD_SOMTEmitC_somtGenerateSections;
typedef FILE*   SOMLINK somTP_SOMTEmitC_somtOpenSymbolsFile(SOMTEmitC *somSelf, 
		string file, 
		string mode);
typedef somTP_SOMTEmitC_somtOpenSymbolsFile *somTD_SOMTEmitC_somtOpenSymbolsFile;
typedef void   SOMLINK somTP_SOMTEmitC_somtSetPredefinedSymbols(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtSetPredefinedSymbols *somTD_SOMTEmitC_somtSetPredefinedSymbols;
typedef void   SOMLINK somTP_SOMTEmitC_somtFileSymbols(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtFileSymbols *somTD_SOMTEmitC_somtFileSymbols;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitProlog *somTD_SOMTEmitC_somtEmitProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitBaseIncludesProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitBaseIncludesProlog *somTD_SOMTEmitC_somtEmitBaseIncludesProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitBaseIncludes(SOMTEmitC *somSelf, 
		SOMTBaseClassEntryC* base);
typedef somTP_SOMTEmitC_somtEmitBaseIncludes *somTD_SOMTEmitC_somtEmitBaseIncludes;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitBaseIncludesEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitBaseIncludesEpilog *somTD_SOMTEmitC_somtEmitBaseIncludesEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitMetaInclude(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitMetaInclude *somTD_SOMTEmitC_somtEmitMetaInclude;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitClass(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitClass *somTD_SOMTEmitC_somtEmitClass;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitMeta(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitMeta *somTD_SOMTEmitC_somtEmitMeta;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitBaseProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitBaseProlog *somTD_SOMTEmitC_somtEmitBaseProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitBase(SOMTEmitC *somSelf, 
		SOMTBaseClassEntryC* base);
typedef somTP_SOMTEmitC_somtEmitBase *somTD_SOMTEmitC_somtEmitBase;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitBaseEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitBaseEpilog *somTD_SOMTEmitC_somtEmitBaseEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitPassthruProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitPassthruProlog *somTD_SOMTEmitC_somtEmitPassthruProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitPassthru(SOMTEmitC *somSelf, 
		SOMTPassthruEntryC* entry);
typedef somTP_SOMTEmitC_somtEmitPassthru *somTD_SOMTEmitC_somtEmitPassthru;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitPassthruEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitPassthruEpilog *somTD_SOMTEmitC_somtEmitPassthruEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitRelease(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitRelease *somTD_SOMTEmitC_somtEmitRelease;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitDataProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitDataProlog *somTD_SOMTEmitC_somtEmitDataProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitData(SOMTEmitC *somSelf, 
		SOMTDataEntryC* entry);
typedef somTP_SOMTEmitC_somtEmitData *somTD_SOMTEmitC_somtEmitData;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitDataEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitDataEpilog *somTD_SOMTEmitC_somtEmitDataEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitAttributeProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitAttributeProlog *somTD_SOMTEmitC_somtEmitAttributeProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitAttribute(SOMTEmitC *somSelf, 
		SOMTAttributeEntryC* att);
typedef somTP_SOMTEmitC_somtEmitAttribute *somTD_SOMTEmitC_somtEmitAttribute;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitAttributeEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitAttributeEpilog *somTD_SOMTEmitC_somtEmitAttributeEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitConstantProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitConstantProlog *somTD_SOMTEmitC_somtEmitConstantProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitConstant(SOMTEmitC *somSelf, 
		SOMTConstEntryC* con);
typedef somTP_SOMTEmitC_somtEmitConstant *somTD_SOMTEmitC_somtEmitConstant;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitConstantEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitConstantEpilog *somTD_SOMTEmitC_somtEmitConstantEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitTypedefProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitTypedefProlog *somTD_SOMTEmitC_somtEmitTypedefProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitTypedef(SOMTEmitC *somSelf, 
		SOMTTypedefEntryC* td);
typedef somTP_SOMTEmitC_somtEmitTypedef *somTD_SOMTEmitC_somtEmitTypedef;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitTypedefEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitTypedefEpilog *somTD_SOMTEmitC_somtEmitTypedefEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitStructProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitStructProlog *somTD_SOMTEmitC_somtEmitStructProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitStruct(SOMTEmitC *somSelf, 
		SOMTStructEntryC* struc);
typedef somTP_SOMTEmitC_somtEmitStruct *somTD_SOMTEmitC_somtEmitStruct;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitStructEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitStructEpilog *somTD_SOMTEmitC_somtEmitStructEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitUnionProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitUnionProlog *somTD_SOMTEmitC_somtEmitUnionProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitUnion(SOMTEmitC *somSelf, 
		SOMTUnionEntryC* un);
typedef somTP_SOMTEmitC_somtEmitUnion *somTD_SOMTEmitC_somtEmitUnion;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitUnionEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitUnionEpilog *somTD_SOMTEmitC_somtEmitUnionEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitEnumProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitEnumProlog *somTD_SOMTEmitC_somtEmitEnumProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitEnum(SOMTEmitC *somSelf, 
		SOMTEnumEntryC* en);
typedef somTP_SOMTEmitC_somtEmitEnum *somTD_SOMTEmitC_somtEmitEnum;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitEnumEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitEnumEpilog *somTD_SOMTEmitC_somtEmitEnumEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitInterfaceProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitInterfaceProlog *somTD_SOMTEmitC_somtEmitInterfaceProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitInterface(SOMTEmitC *somSelf, 
		SOMTClassEntryC* intfc);
typedef somTP_SOMTEmitC_somtEmitInterface *somTD_SOMTEmitC_somtEmitInterface;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitInterfaceEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitInterfaceEpilog *somTD_SOMTEmitC_somtEmitInterfaceEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitModuleProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitModuleProlog *somTD_SOMTEmitC_somtEmitModuleProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitModule(SOMTEmitC *somSelf, 
		SOMTModuleEntryC* mod);
typedef somTP_SOMTEmitC_somtEmitModule *somTD_SOMTEmitC_somtEmitModule;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitModuleEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitModuleEpilog *somTD_SOMTEmitC_somtEmitModuleEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitMethodsProlog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitMethodsProlog *somTD_SOMTEmitC_somtEmitMethodsProlog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitMethods(SOMTEmitC *somSelf, 
		SOMTMethodEntryC* method);
typedef somTP_SOMTEmitC_somtEmitMethods *somTD_SOMTEmitC_somtEmitMethods;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitMethodsEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitMethodsEpilog *somTD_SOMTEmitC_somtEmitMethodsEpilog;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitMethod(SOMTEmitC *somSelf, 
		SOMTMethodEntryC* entry);
typedef somTP_SOMTEmitC_somtEmitMethod *somTD_SOMTEmitC_somtEmitMethod;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitEpilog(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtEmitEpilog *somTD_SOMTEmitC_somtEmitEpilog;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanBases(SOMTEmitC *somSelf, 
		string prolog, 
		string each, 
		string epilog);
typedef somTP_SOMTEmitC_somtScanBases *somTD_SOMTEmitC_somtScanBases;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtCheckVisibility(SOMTEmitC *somSelf, 
		SOMTMethodEntryC* entry);
typedef somTP_SOMTEmitC_somtCheckVisibility *somTD_SOMTEmitC_somtCheckVisibility;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtNew(SOMTEmitC *somSelf, 
		SOMTMethodEntryC* entry);
typedef somTP_SOMTEmitC_somtNew *somTD_SOMTEmitC_somtNew;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtImplemented(SOMTEmitC *somSelf, 
		SOMTMethodEntryC* entry);
typedef somTP_SOMTEmitC_somtImplemented *somTD_SOMTEmitC_somtImplemented;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtOverridden(SOMTEmitC *somSelf, 
		SOMTMethodEntryC* entry);
typedef somTP_SOMTEmitC_somtOverridden *somTD_SOMTEmitC_somtOverridden;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtInherited(SOMTEmitC *somSelf, 
		SOMTMethodEntryC* entry);
typedef somTP_SOMTEmitC_somtInherited *somTD_SOMTEmitC_somtInherited;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtAllVisible(SOMTEmitC *somSelf, 
		SOMTMethodEntryC* entry);
typedef somTP_SOMTEmitC_somtAllVisible *somTD_SOMTEmitC_somtAllVisible;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtAll(SOMTEmitC *somSelf, 
		SOMTMethodEntryC* entry);
typedef somTP_SOMTEmitC_somtAll *somTD_SOMTEmitC_somtAll;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtNewNoProc(SOMTEmitC *somSelf, 
		SOMTEntryC* entry);
typedef somTP_SOMTEmitC_somtNewNoProc *somTD_SOMTEmitC_somtNewNoProc;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtPrivOrPub(SOMTEmitC *somSelf, 
		SOMTEntryC* entry);
typedef somTP_SOMTEmitC_somtPrivOrPub *somTD_SOMTEmitC_somtPrivOrPub;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtNewProc(SOMTEmitC *somSelf, 
		SOMTEntryC* entry);
typedef somTP_SOMTEmitC_somtNewProc *somTD_SOMTEmitC_somtNewProc;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtLink(SOMTEmitC *somSelf, 
		SOMTEntryC* entry);
typedef somTP_SOMTEmitC_somtLink *somTD_SOMTEmitC_somtLink;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtVA(SOMTEmitC *somSelf, 
		SOMTEntryC* entry);
typedef somTP_SOMTEmitC_somtVA *somTD_SOMTEmitC_somtVA;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanMethods(SOMTEmitC *somSelf, 
		string filter, 
		string prolog, 
		string each, 
		string epilog, 
		boolean forceProlog);
typedef somTP_SOMTEmitC_somtScanMethods *somTD_SOMTEmitC_somtScanMethods;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanConstants(SOMTEmitC *somSelf, 
		string prolog, 
		string each, 
		string epilog);
typedef somTP_SOMTEmitC_somtScanConstants *somTD_SOMTEmitC_somtScanConstants;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanTypedefs(SOMTEmitC *somSelf, 
		string prolog, 
		string each, 
		string epilog);
typedef somTP_SOMTEmitC_somtScanTypedefs *somTD_SOMTEmitC_somtScanTypedefs;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanStructs(SOMTEmitC *somSelf, 
		string prolog, 
		string each, 
		string epilog);
typedef somTP_SOMTEmitC_somtScanStructs *somTD_SOMTEmitC_somtScanStructs;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanUnions(SOMTEmitC *somSelf, 
		string prolog, 
		string each, 
		string epilog);
typedef somTP_SOMTEmitC_somtScanUnions *somTD_SOMTEmitC_somtScanUnions;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanEnums(SOMTEmitC *somSelf, 
		string prolog, 
		string each, 
		string epilog);
typedef somTP_SOMTEmitC_somtScanEnums *somTD_SOMTEmitC_somtScanEnums;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanData(SOMTEmitC *somSelf, 
		string prolog, 
		string each, 
		string epilog);
typedef somTP_SOMTEmitC_somtScanData *somTD_SOMTEmitC_somtScanData;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanAttributes(SOMTEmitC *somSelf, 
		string prolog, 
		string each, 
		string epilog);
typedef somTP_SOMTEmitC_somtScanAttributes *somTD_SOMTEmitC_somtScanAttributes;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanInterfaces(SOMTEmitC *somSelf, 
		string prolog, 
		string each, 
		string epilog);
typedef somTP_SOMTEmitC_somtScanInterfaces *somTD_SOMTEmitC_somtScanInterfaces;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanModules(SOMTEmitC *somSelf, 
		string prolog, 
		string each, 
		string epilog);
typedef somTP_SOMTEmitC_somtScanModules *somTD_SOMTEmitC_somtScanModules;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanPassthru(SOMTEmitC *somSelf, 
		boolean before, 
		string prolog, 
		string each, 
		string epilog);
typedef somTP_SOMTEmitC_somtScanPassthru *somTD_SOMTEmitC_somtScanPassthru;
typedef void   SOMLINK somTP_SOMTEmitC_somtEmitFullPassthru(SOMTEmitC *somSelf, 
		boolean before, 
		string language);
typedef somTP_SOMTEmitC_somtEmitFullPassthru *somTD_SOMTEmitC_somtEmitFullPassthru;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanDataF(SOMTEmitC *somSelf, 
		string filter, 
		string prolog, 
		string each, 
		string epilog, 
		boolean forceProlog);
typedef somTP_SOMTEmitC_somtScanDataF *somTD_SOMTEmitC_somtScanDataF;
typedef boolean   SOMLINK somTP_SOMTEmitC_somtScanBasesF(SOMTEmitC *somSelf, 
		string filter, 
		string prolog, 
		string each, 
		string epilog, 
		boolean forceProlog);
typedef somTP_SOMTEmitC_somtScanBasesF *somTD_SOMTEmitC_somtScanBasesF;
typedef string   SOMLINK somTP_SOMTEmitC_somtGetGlobalModifierValue(SOMTEmitC *somSelf, 
		string modifierName);
typedef somTP_SOMTEmitC_somtGetGlobalModifierValue *somTD_SOMTEmitC_somtGetGlobalModifierValue;
typedef SOMTEntryC*   SOMLINK somTP_SOMTEmitC_somtGetFirstGlobalDefinition(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtGetFirstGlobalDefinition *somTD_SOMTEmitC_somtGetFirstGlobalDefinition;
typedef SOMTEntryC*   SOMLINK somTP_SOMTEmitC_somtGetNextGlobalDefinition(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somtGetNextGlobalDefinition *somTD_SOMTEmitC_somtGetNextGlobalDefinition;

/*
 * -- Typedefs for Reintroduced Wrapper Methods
 */
typedef void   SOMLINK somTP_SOMTEmitC_somDefaultInit(SOMTEmitC *somSelf, 
		som3InitCtrl* ctrl);
typedef somTP_SOMTEmitC_somDefaultInit *somTD_SOMTEmitC_somDefaultInit;
typedef void   SOMLINK somTP_SOMTEmitC_somDestruct(SOMTEmitC *somSelf, 
		octet doFree, 
		som3DestructCtrl* ctrl);
typedef somTP_SOMTEmitC_somDestruct *somTD_SOMTEmitC_somDestruct;
typedef void   SOMLINK somTP_SOMTEmitC_somDefaultCopyInit(SOMTEmitC *somSelf, 
		som3InitCtrl* ctrl, 
		SOMObject* fromObj);
typedef somTP_SOMTEmitC_somDefaultCopyInit *somTD_SOMTEmitC_somDefaultCopyInit;
typedef SOMTEmitC*   SOMLINK somTP_SOMTEmitC_somDefaultAssign(SOMTEmitC *somSelf, 
		som3AssignCtrl* ctrl, 
		SOMObject* fromObj);
typedef somTP_SOMTEmitC_somDefaultAssign *somTD_SOMTEmitC_somDefaultAssign;
typedef void   SOMLINK somTP_SOMTEmitC_somDefaultConstCopyInit(SOMTEmitC *somSelf, 
		som3InitCtrl* ctrl, 
		SOMObject* fromObj);
typedef somTP_SOMTEmitC_somDefaultConstCopyInit *somTD_SOMTEmitC_somDefaultConstCopyInit;
typedef void   SOMLINK somTP_SOMTEmitC_somDefaultVCopyInit(SOMTEmitC *somSelf, 
		som3InitCtrl* ctrl, 
		SOMObject* fromObj);
typedef somTP_SOMTEmitC_somDefaultVCopyInit *somTD_SOMTEmitC_somDefaultVCopyInit;
typedef void   SOMLINK somTP_SOMTEmitC_somDefaultConstVCopyInit(SOMTEmitC *somSelf, 
		som3InitCtrl* ctrl, 
		SOMObject* fromObj);
typedef somTP_SOMTEmitC_somDefaultConstVCopyInit *somTD_SOMTEmitC_somDefaultConstVCopyInit;
typedef SOMTEmitC*   SOMLINK somTP_SOMTEmitC_somDefaultConstAssign(SOMTEmitC *somSelf, 
		som3AssignCtrl* ctrl, 
		SOMObject* fromObj);
typedef somTP_SOMTEmitC_somDefaultConstAssign *somTD_SOMTEmitC_somDefaultConstAssign;
typedef SOMTEmitC*   SOMLINK somTP_SOMTEmitC_somDefaultVAssign(SOMTEmitC *somSelf, 
		som3AssignCtrl* ctrl, 
		SOMObject* fromObj);
typedef somTP_SOMTEmitC_somDefaultVAssign *somTD_SOMTEmitC_somDefaultVAssign;
typedef SOMTEmitC*   SOMLINK somTP_SOMTEmitC_somDefaultConstVAssign(SOMTEmitC *somSelf, 
		som3AssignCtrl* ctrl, 
		SOMObject* fromObj);
typedef somTP_SOMTEmitC_somDefaultConstVAssign *somTD_SOMTEmitC_somDefaultConstVAssign;
typedef void   SOMLINK somTP_SOMTEmitC_somInit(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somInit *somTD_SOMTEmitC_somInit;
typedef void   SOMLINK somTP_SOMTEmitC_somFree(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somFree *somTD_SOMTEmitC_somFree;
typedef void   SOMLINK somTP_SOMTEmitC_somUninit(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somUninit *somTD_SOMTEmitC_somUninit;
typedef SOMClass*   SOMLINK somTP_SOMTEmitC_somGetClass(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somGetClass *somTD_SOMTEmitC_somGetClass;
typedef string   SOMLINK somTP_SOMTEmitC_somGetClassName(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somGetClassName *somTD_SOMTEmitC_somGetClassName;
typedef long   SOMLINK somTP_SOMTEmitC_somGetSize(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somGetSize *somTD_SOMTEmitC_somGetSize;
typedef boolean   SOMLINK somTP_SOMTEmitC_somIsA(SOMTEmitC *somSelf, 
		SOMClass* aClassObj);
typedef somTP_SOMTEmitC_somIsA *somTD_SOMTEmitC_somIsA;
typedef boolean   SOMLINK somTP_SOMTEmitC_somIsInstanceOf(SOMTEmitC *somSelf, 
		SOMClass* aClassObj);
typedef somTP_SOMTEmitC_somIsInstanceOf *somTD_SOMTEmitC_somIsInstanceOf;
typedef boolean   SOMLINK somTP_SOMTEmitC_somRespondsTo(SOMTEmitC *somSelf, 
		somId mId);
typedef somTP_SOMTEmitC_somRespondsTo *somTD_SOMTEmitC_somRespondsTo;
typedef boolean   SOMLINK somTP_SOMTEmitC_somDispatch(SOMTEmitC *somSelf, 
		somToken* retValue, 
		somId methodId, 
		va_list ap);
typedef somTP_SOMTEmitC_somDispatch *somTD_SOMTEmitC_somDispatch;
typedef boolean   SOMLINK somTP_SOMTEmitC_somClassDispatch(SOMTEmitC *somSelf, 
		SOMClass* clsObj, 
		somToken* retValue, 
		somId methodId, 
		va_list ap);
typedef somTP_SOMTEmitC_somClassDispatch *somTD_SOMTEmitC_somClassDispatch;
typedef boolean   SOMLINK somTP_SOMTEmitC_somCastObj(SOMTEmitC *somSelf, 
		SOMClass* cls);
typedef somTP_SOMTEmitC_somCastObj *somTD_SOMTEmitC_somCastObj;
typedef boolean   SOMLINK somTP_SOMTEmitC_somResetObj(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somResetObj *somTD_SOMTEmitC_somResetObj;
typedef void   SOMLINK somTP_SOMTEmitC_somDispatchV(SOMTEmitC *somSelf, 
		somId methodId, 
		somId descriptor, 
		va_list ap);
typedef somTP_SOMTEmitC_somDispatchV *somTD_SOMTEmitC_somDispatchV;
typedef long   SOMLINK somTP_SOMTEmitC_somDispatchL(SOMTEmitC *somSelf, 
		somId methodId, 
		somId descriptor, 
		va_list ap);
typedef somTP_SOMTEmitC_somDispatchL *somTD_SOMTEmitC_somDispatchL;
typedef void*   SOMLINK somTP_SOMTEmitC_somDispatchA(SOMTEmitC *somSelf, 
		somId methodId, 
		somId descriptor, 
		va_list ap);
typedef somTP_SOMTEmitC_somDispatchA *somTD_SOMTEmitC_somDispatchA;
typedef double   SOMLINK somTP_SOMTEmitC_somDispatchD(SOMTEmitC *somSelf, 
		somId methodId, 
		somId descriptor, 
		va_list ap);
typedef somTP_SOMTEmitC_somDispatchD *somTD_SOMTEmitC_somDispatchD;
typedef SOMObject*   SOMLINK somTP_SOMTEmitC_somPrintSelf(SOMTEmitC *somSelf);
typedef somTP_SOMTEmitC_somPrintSelf *somTD_SOMTEmitC_somPrintSelf;
typedef void   SOMLINK somTP_SOMTEmitC_somDumpSelf(SOMTEmitC *somSelf, 
		long level);
typedef somTP_SOMTEmitC_somDumpSelf *somTD_SOMTEmitC_somDumpSelf;
typedef void   SOMLINK somTP_SOMTEmitC_somDumpSelfInt(SOMTEmitC *somSelf, 
		long level);
typedef somTP_SOMTEmitC_somDumpSelfInt *somTD_SOMTEmitC_somDumpSelfInt;
}

#endif /* SOMTEmitC_API */


/*
 * -- This emitter treats Method Tokens as Thunks by default.
 * -- Use the sc modifier "nothunks" to change this default
 */
#undef somresolve_
#define somresolve_(obj,mToken) ((somMethodProc*)((void)obj, mToken))

/*
 * -- The C++ Wrapper Class for SOMTEmitC
 */
class SOMTEmitC : public SOMObject
{
/*
 *  This is the pluggable unit in the SOM emitter framework. An emitter
 *  is constructed by subclassing this class and then running the
 *  master emitter program providing the name of the subclass as one of
 *  its command line arguments.
 *  The concepts of this class are simple:
 * 
 *    Emitters always consist of a set of sections
 *    The sections are in a particular order for any particular
 *    emitter, and the order does not vary with the data processed by
 *    the emitter.
 *    A number of the sections of an emitter are common (maybe with
 *    slight variation) across several (or even most) emitters.
 *    There are a number of constructs that occur in varying numbers,
 *    eg, method declarations, data declarations, and attribute
 *    declarations.
 *  Consequently, this class provides methods for:
 *    Methods for many common sections, including several that may be
 *    useful without overridding in several different emitters
 *    Sequencing through the sections of the emitter
 *    Iterating through the constructs that occur in varying numbers
 */
public:

// SOMTEmitC::new creates the class object if necessary, and then uses somNewNoInit
// to allocate memory and create the object. Initialization is in ctors.
void *operator new(size_t)
{
   if (!_SOMTEmitC) SOMTEmitCNewClass(SOMTEmitC_MajorVersion,SOMTEmitC_MinorVersion);
   return (void*)
      SOM_Resolve(_SOMTEmitC,SOMClass,somNewNoInit)
         ((SOMClass *)((void*)_SOMTEmitC));
}

// SOMTEmitC::delete uses somDestruct.
void operator delete(void * obj)
{
   if (obj && *(void**)obj) {
      SOM_Resolve(obj,SOMObject,somFree)
         ((SOMObject*)obj);
   }
}

SOMTEmitC& operator=(SOMTEmitC& fromObj)
{
   this->somDefaultAssign(0,(SOMObject*)((void*)&fromObj));
   return *this;
}

SOMTEmitC()
{
   if (*(void**)this != 
       ((somParentMtabStructPtr)
        (SOMTEmitCCClassData.parentMtab))->mtab)
      return;
   ((SOMObject*)((void*)this))->somDefaultInit(0);
}

SOMTEmitC(SOMTEmitC* fromObj)
{
   if (*(void**)this != 
       ((somParentMtabStructPtr)
        (SOMTEmitCCClassData.parentMtab))->mtab)
      return;
   ((SOMObject*)((void*)this))->somDefaultCopyInit(0,((SOMObject*)((void*)fromObj)));
}

#ifdef __IBMCPP__
#pragma info(nocnv,nopar)
#endif
SOMTEmitC(const SOMTEmitC* fromObj)
{
   if (*(void**)this != 
       ((somParentMtabStructPtr)
        (SOMTEmitCCClassData.parentMtab))->mtab)
      return;
   ((SOMObject*)((void*)this))->somDefaultConstCopyInit(0,((SOMObject*)((void*)fromObj)));
}
#ifdef __IBMCPP__
#pragma info(restore)
#endif


/* method: _get_somtTemplate */
SOMTTemplateOutputC*   _get_somtTemplate()
{
/*
 *  The template is to provide template output and maintains a symbol
 *  table that provides a sort of global context for the emitter.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,_get_somtTemplate)
	(this);
}


/* method: _set_somtTemplate */
void   _set_somtTemplate(SOMTTemplateOutputC* somtTemplate)
{
/*
 *  The template is to provide template output and maintains a symbol
 *  table that provides a sort of global context for the emitter.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,_set_somtTemplate)
	(this,somtTemplate);
}


/* method: _get_somtTargetFile */
FILE*   _get_somtTargetFile()
{
/*
 *  The target file is the one to which all emitter output is to be
 *  directed.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,_get_somtTargetFile)
	(this);
}


/* method: _set_somtTargetFile */
void   _set_somtTargetFile(FILE* somtTargetFile)
{
/*
 *  The target file is the one to which all emitter output is to be
 *  directed.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,_set_somtTargetFile)
	(this,somtTargetFile);
}


/* method: _get_somtTargetClass */
SOMTClassEntryC*   _get_somtTargetClass()
{
/*
 *  The target class is the class definition for which code is to be
 *  emitted.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,_get_somtTargetClass)
	(this);
}


/* method: _set_somtTargetClass */
void   _set_somtTargetClass(SOMTClassEntryC* somtTargetClass)
{
/*
 *  The target class is the class definition for which code is to be
 *  emitted.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,_set_somtTargetClass)
	(this,somtTargetClass);
}


/* method: _get_somtTargetModule */
SOMTModuleEntryC*   _get_somtTargetModule()
{
/*
 *  The target module is the module definition for which code is to be
 *  emitted.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,_get_somtTargetModule)
	(this);
}


/* method: _set_somtTargetModule */
void   _set_somtTargetModule(SOMTModuleEntryC* somtTargetModule)
{
/*
 *  The target module is the module definition for which code is to be
 *  emitted.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,_set_somtTargetModule)
	(this,somtTargetModule);
}


/* method: _get_somtTargetType */
SOMTTargetTypeT   _get_somtTargetType()
{
/*
 *  The target type indicates what type of output file is being
 *  produced, public, private, or implementation.  This allows the
 *  same emitter subclass to produce several different output files
 *  that generally differ only in how much of the class definition
 *  they cover. Eg, .csc, .sc, and .psc.
 *  This is attribute is for OIDL compatibility only.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,_get_somtTargetType)
	(this);
}


/* method: _set_somtTargetType */
void   _set_somtTargetType(SOMTTargetTypeT somtTargetType)
{
/*
 *  The target type indicates what type of output file is being
 *  produced, public, private, or implementation.  This allows the
 *  same emitter subclass to produce several different output files
 *  that generally differ only in how much of the class definition
 *  they cover. Eg, .csc, .sc, and .psc.
 *  This is attribute is for OIDL compatibility only.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,_set_somtTargetType)
	(this,somtTargetType);
}


/* method: _get_somtEmitterName */
string   _get_somtEmitterName()
{
/*
 *  The short name of the emitter (the name used to invoke it via the
 *  SOM Compiler.  Typically this is the file stem of the subclass
 *  of SOMTEmitC. This attribute should be set in the driver program
 *  that runs the emitter.  It is used to filter passthrus so that only
 *  passthrus directed to a particular emitter are seen by it.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,_get_somtEmitterName)
	(this);
}


/* method: _set_somtEmitterName */
void   _set_somtEmitterName(string somtEmitterName)
{
/*
 *  The short name of the emitter (the name used to invoke it via the
 *  SOM Compiler.  Typically this is the file stem of the subclass
 *  of SOMTEmitC. This attribute should be set in the driver program
 *  that runs the emitter.  It is used to filter passthrus so that only
 *  passthrus directed to a particular emitter are seen by it.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,_set_somtEmitterName)
	(this,somtEmitterName);
}


/* method: somtGenerateSections */
boolean   somtGenerateSections()
{
/*
 *  Calls each of the section methods in order.  The order is:
 * 
 *    somtEmitProlog
 *    when emitting a class:
 *    	  somtEmitClass
 *    	  somtEmitBase
 *    	  somtEmitMeta
 *    somtEmitConstant
 *    somtEmitTypedef
 *    somtEmitStruct
 *    somtEmitUnion
 *    somtEmitEnum
 *    when emitting a class:
 *       somtEmitAttribute
 *       somtEmitMethod
 *       somtEmitRelease
 *       somtEmitPassthru
 *       somtEmitData
 *    when emitting a module:
 *        somtEmitInterface
 *        somtEmitModule
 *    somtEmitEpilog
 * 
 *  This method will need to be overridden by many emitters in order
 *  to rearange the order of the sections and to add or delete
 *  sections.
 *  Note: repeating sections such as methods, data, and passthru,
 *  have a prolog and epilog method as well. The prolog method is
 *  called before the first sections is processed and the epilog method
 *  is called after the last section is processed.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtGenerateSections)
	(this);
}


/* method: somtOpenSymbolsFile */
FILE*   somtOpenSymbolsFile(string file, 
		string mode)
{
/*
 *  This method attempts to open the symbols file.
 *  If file doesn't exist then it will attempt to find it in the
 *  directories specified in the SMINCLUDE environment variable.
 *  If the file can be found a FILE * pointer is returned, otherwise
 *  NULL is returned.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtOpenSymbolsFile)
	(this,file,mode);
}


/* method: somtSetPredefinedSymbols */
void   somtSetPredefinedSymbols()
{
/*
 *  Set predefined symbols that are used for such things as section
 *  names etc.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtSetPredefinedSymbols)
	(this);
}


/* method: somtFileSymbols */
void   somtFileSymbols()
{
/*
 *  Symbols that are common to the file.  This includes the target
 *  class symbols, and the metaclass symbols, and special symbols
 *  like <timeStamp>.  IE, all symbols that have a single definition.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtFileSymbols)
	(this);
}


/* method: somtEmitProlog */
void   somtEmitProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitProlog)
	(this);
}


/* method: somtEmitBaseIncludesProlog */
void   somtEmitBaseIncludesProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitBaseIncludesProlog)
	(this);
}


/* method: somtEmitBaseIncludes */
void   somtEmitBaseIncludes(SOMTBaseClassEntryC* base)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitBaseIncludes)
	(this,base);
}


/* method: somtEmitBaseIncludesEpilog */
void   somtEmitBaseIncludesEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitBaseIncludesEpilog)
	(this);
}


/* method: somtEmitMetaInclude */
void   somtEmitMetaInclude()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitMetaInclude)
	(this);
}


/* method: somtEmitClass */
void   somtEmitClass()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitClass)
	(this);
}


/* method: somtEmitMeta */
void   somtEmitMeta()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitMeta)
	(this);
}


/* method: somtEmitBaseProlog */
void   somtEmitBaseProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitBaseProlog)
	(this);
}


/* method: somtEmitBase */
void   somtEmitBase(SOMTBaseClassEntryC* base)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitBase)
	(this,base);
}


/* method: somtEmitBaseEpilog */
void   somtEmitBaseEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitBaseEpilog)
	(this);
}


/* method: somtEmitPassthruProlog */
void   somtEmitPassthruProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitPassthruProlog)
	(this);
}


/* method: somtEmitPassthru */
void   somtEmitPassthru(SOMTPassthruEntryC* entry)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitPassthru)
	(this,entry);
}


/* method: somtEmitPassthruEpilog */
void   somtEmitPassthruEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitPassthruEpilog)
	(this);
}


/* method: somtEmitRelease */
void   somtEmitRelease()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitRelease)
	(this);
}


/* method: somtEmitDataProlog */
void   somtEmitDataProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitDataProlog)
	(this);
}


/* method: somtEmitData */
void   somtEmitData(SOMTDataEntryC* entry)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitData)
	(this,entry);
}


/* method: somtEmitDataEpilog */
void   somtEmitDataEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitDataEpilog)
	(this);
}


/* method: somtEmitAttributeProlog */
void   somtEmitAttributeProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitAttributeProlog)
	(this);
}


/* method: somtEmitAttribute */
void   somtEmitAttribute(SOMTAttributeEntryC* att)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitAttribute)
	(this,att);
}


/* method: somtEmitAttributeEpilog */
void   somtEmitAttributeEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitAttributeEpilog)
	(this);
}


/* method: somtEmitConstantProlog */
void   somtEmitConstantProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitConstantProlog)
	(this);
}


/* method: somtEmitConstant */
void   somtEmitConstant(SOMTConstEntryC* con)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitConstant)
	(this,con);
}


/* method: somtEmitConstantEpilog */
void   somtEmitConstantEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitConstantEpilog)
	(this);
}


/* method: somtEmitTypedefProlog */
void   somtEmitTypedefProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitTypedefProlog)
	(this);
}


/* method: somtEmitTypedef */
void   somtEmitTypedef(SOMTTypedefEntryC* td)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitTypedef)
	(this,td);
}


/* method: somtEmitTypedefEpilog */
void   somtEmitTypedefEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitTypedefEpilog)
	(this);
}


/* method: somtEmitStructProlog */
void   somtEmitStructProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitStructProlog)
	(this);
}


/* method: somtEmitStruct */
void   somtEmitStruct(SOMTStructEntryC* struc)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitStruct)
	(this,struc);
}


/* method: somtEmitStructEpilog */
void   somtEmitStructEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitStructEpilog)
	(this);
}


/* method: somtEmitUnionProlog */
void   somtEmitUnionProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitUnionProlog)
	(this);
}


/* method: somtEmitUnion */
void   somtEmitUnion(SOMTUnionEntryC* un)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitUnion)
	(this,un);
}


/* method: somtEmitUnionEpilog */
void   somtEmitUnionEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitUnionEpilog)
	(this);
}


/* method: somtEmitEnumProlog */
void   somtEmitEnumProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitEnumProlog)
	(this);
}


/* method: somtEmitEnum */
void   somtEmitEnum(SOMTEnumEntryC* en)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitEnum)
	(this,en);
}


/* method: somtEmitEnumEpilog */
void   somtEmitEnumEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitEnumEpilog)
	(this);
}


/* method: somtEmitInterfaceProlog */
void   somtEmitInterfaceProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitInterfaceProlog)
	(this);
}


/* method: somtEmitInterface */
void   somtEmitInterface(SOMTClassEntryC* intfc)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitInterface)
	(this,intfc);
}


/* method: somtEmitInterfaceEpilog */
void   somtEmitInterfaceEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitInterfaceEpilog)
	(this);
}


/* method: somtEmitModuleProlog */
void   somtEmitModuleProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitModuleProlog)
	(this);
}


/* method: somtEmitModule */
void   somtEmitModule(SOMTModuleEntryC* mod)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitModule)
	(this,mod);
}


/* method: somtEmitModuleEpilog */
void   somtEmitModuleEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitModuleEpilog)
	(this);
}


/* method: somtEmitMethodsProlog */
void   somtEmitMethodsProlog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitMethodsProlog)
	(this);
}


/* method: somtEmitMethods */
void   somtEmitMethods(SOMTMethodEntryC* method)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitMethods)
	(this,method);
}


/* method: somtEmitMethodsEpilog */
void   somtEmitMethodsEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitMethodsEpilog)
	(this);
}


/* method: somtEmitMethod */
void   somtEmitMethod(SOMTMethodEntryC* entry)
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitMethod)
	(this,entry);
}


/* method: somtEmitEpilog */
void   somtEmitEpilog()
{
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitEpilog)
	(this);
}


/* method: somtScanBases */
boolean   somtScanBases(string prolog, 
		string each, 
		string epilog)
{
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanBases)
	(this,prolog,each,epilog);
}


/* method: somtCheckVisibility */
boolean   somtCheckVisibility(SOMTMethodEntryC* entry)
{
/*
 *  Return 1 (true) if <entry> should be visible in the current
 *  target file.  This method is used by each of the following filter
 *  methods that are concerned with visibility.
 *  The default rule for visibility is:
 *    only private methods are visible in private target files,
 *    only public methods are visibile in public target files,
 *    all methods are visibile in implementation or <somtAllE> target
 *    files.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtCheckVisibility)
	(this,entry);
}


/* method: somtNew */
boolean   somtNew(SOMTMethodEntryC* entry)
{
/*
 *  Returns 1 (true) if <entry> is a method introduced by the target
 *  class and its visibility matches <somtTargetType> (somtImplementationE
 *  matches both private and public)
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtNew)
	(this,entry);
}


/* method: somtImplemented */
boolean   somtImplemented(SOMTMethodEntryC* entry)
{
/*
 *  Returns 1 (true) if <entry> is a method introduced or overridden
 *  by the target class and its visibility matches <somtTargetType>
 *  (somtImplementationE matches both private and public)
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtImplemented)
	(this,entry);
}


/* method: somtOverridden */
boolean   somtOverridden(SOMTMethodEntryC* entry)
{
/*
 *  Returns 1 (true) if <entry> is an overridding method of the target class
 *  and its visibility matches <somtTargetType> (somtImplementationE
 *  matches both private and public)
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtOverridden)
	(this,entry);
}


/* method: somtInherited */
boolean   somtInherited(SOMTMethodEntryC* entry)
{
/*
 *  Returns 1 (true) if <entry> is inherited
 *  by the target class and its visibility matches <somtTargetType>
 *  (somtImplementationE matches both private and public)
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtInherited)
	(this,entry);
}


/* method: somtAllVisible */
boolean   somtAllVisible(SOMTMethodEntryC* entry)
{
/*
 *  Returns 1 (true) if <entry> is supported by the target class and
 *  its visibility matches <somtTargetType> (somtImplementationE
 *  matches both private and public)
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtAllVisible)
	(this,entry);
}


/* method: somtAll */
boolean   somtAll(SOMTMethodEntryC* entry)
{
/*
 *  Returns 1 (true) if <entry> is supported by the target class.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtAll)
	(this,entry);
}


/* method: somtNewNoProc */
boolean   somtNewNoProc(SOMTEntryC* entry)
{
/*
 *  Returns 1 (true) if somtNew does and the method
 *  IS NOT a direct call Procedure.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtNewNoProc)
	(this,entry);
}


/* method: somtPrivOrPub */
boolean   somtPrivOrPub(SOMTEntryC* entry)
{
/*
 *  Returns 1 (true) if entry is Private or Public.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtPrivOrPub)
	(this,entry);
}


/* method: somtNewProc */
boolean   somtNewProc(SOMTEntryC* entry)
{
/*
 *  Returns 1 (true) if somtNew does and the method
 *  IS a direct call Procedure.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtNewProc)
	(this,entry);
}


/* method: somtLink */
boolean   somtLink(SOMTEntryC* entry)
{
/*
 *  Returns 1 (true) if "nolink" is not set.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtLink)
	(this,entry);
}


/* method: somtVA */
boolean   somtVA(SOMTEntryC* entry)
{
/*
 *  Returns 1 (true) if entry is a VarArgs method.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtVA)
	(this,entry);
}


/* method: somtScanMethods */
boolean   somtScanMethods(string filter, 
		string prolog, 
		string each, 
		string epilog, 
		boolean forceProlog)
{
/*
 *  Will only call <each> on methods accepted by <filter>.
 *  If <forceProlog> is not true then the prolog and epilog emiters
 *  will be called only if there is at least one method that passes
 *  the filter.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanMethods)
	(this,filter,prolog,each,epilog,forceProlog);
}


/* method: somtScanConstants */
boolean   somtScanConstants(string prolog, 
		string each, 
		string epilog)
{
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanConstants)
	(this,prolog,each,epilog);
}


/* method: somtScanTypedefs */
boolean   somtScanTypedefs(string prolog, 
		string each, 
		string epilog)
{
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanTypedefs)
	(this,prolog,each,epilog);
}


/* method: somtScanStructs */
boolean   somtScanStructs(string prolog, 
		string each, 
		string epilog)
{
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanStructs)
	(this,prolog,each,epilog);
}


/* method: somtScanUnions */
boolean   somtScanUnions(string prolog, 
		string each, 
		string epilog)
{
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanUnions)
	(this,prolog,each,epilog);
}


/* method: somtScanEnums */
boolean   somtScanEnums(string prolog, 
		string each, 
		string epilog)
{
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanEnums)
	(this,prolog,each,epilog);
}


/* method: somtScanData */
boolean   somtScanData(string prolog, 
		string each, 
		string epilog)
{
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanData)
	(this,prolog,each,epilog);
}


/* method: somtScanAttributes */
boolean   somtScanAttributes(string prolog, 
		string each, 
		string epilog)
{
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanAttributes)
	(this,prolog,each,epilog);
}


/* method: somtScanInterfaces */
boolean   somtScanInterfaces(string prolog, 
		string each, 
		string epilog)
{
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanInterfaces)
	(this,prolog,each,epilog);
}


/* method: somtScanModules */
boolean   somtScanModules(string prolog, 
		string each, 
		string epilog)
{
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanModules)
	(this,prolog,each,epilog);
}


/* method: somtScanPassthru */
boolean   somtScanPassthru(boolean before, 
		string prolog, 
		string each, 
		string epilog)
{
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanPassthru)
	(this,before,prolog,each,epilog);
}


/* method: somtEmitFullPassthru */
void   somtEmitFullPassthru(boolean before, 
		string language)
{
/*
 *  Emits each passthru section defined for the language and targetType,
 *  and the result of the somtIsBeforePassthru method is equal to the
 *  before parameter.  (before = 1(true), or before = 0(false), i.e. after.)
 */
   SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtEmitFullPassthru)
	(this,before,language);
}


/* method: somtScanDataF */
boolean   somtScanDataF(string filter, 
		string prolog, 
		string each, 
		string epilog, 
		boolean forceProlog)
{
/*
 *  This method is like somtScanData but it also provides a paramater
 *  for a filter method.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanDataF)
	(this,filter,prolog,each,epilog,forceProlog);
}


/* method: somtScanBasesF */
boolean   somtScanBasesF(string filter, 
		string prolog, 
		string each, 
		string epilog, 
		boolean forceProlog)
{
/*
 *  This method is like somtScanBases but it also provides a paramater
 *  for a filter method.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtScanBasesF)
	(this,filter,prolog,each,epilog,forceProlog);
}


/* method: somtGetGlobalModifierValue */
string   somtGetGlobalModifierValue(string modifierName)
{
/*
 *  Returns the value of the specified global modifier.
 *  Global modifiers are specified when the SOM Compiler is invoked,
 *  via the "-a" option.  For example,
 *                        sc -a"foo=bar"  file.idl
 *  specifies to the SOM Compiler and the emitters being run that
 *  the global modifier "foo" has the value "bar."
 *  Values of global modifiers are transient; they last only for the
 *  duration of the compile for which they were specified.
 *  If a modifier is specified in the "sc" command with no value,
 *  as in
 *                        sc -afoo file.idl
 *  then the result of this method will be non-NULL.
 *  If no such modifier is specified, then the result is NULL.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtGetGlobalModifierValue)
	(this,modifierName);
}


/* method: somtGetFirstGlobalDefinition */
SOMTEntryC*   somtGetFirstGlobalDefinition()
{
/*
 *  Returns the first type or constant definition that is not
 *  associated with any interface or module.
 *  These global definitions must be surrounded by the somemittypes
 *  pragmas for them to be visible via this method.
 *  E.g., #pragma somemittypes on
 *        ....
 *        #pragma someemittypes off
 *  The list of global definitions returned by this method and
 *  the somtGetNextGlobalDefinition method may include entries
 *  for forward declarations as well as typedefs and constants.
 *  Global structs and unions are also included in the list.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtGetFirstGlobalDefinition)
	(this);
}


/* method: somtGetNextGlobalDefinition */
SOMTEntryC*   somtGetNextGlobalDefinition()
{
/*
 *  Returns the next type or constant definition that is not
 *  associated with any interface or module, relative to a
 *  previous call to somtGetFirstGlobalDefinition or
 *  somtGetNextGlobalDefinition.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMTEmitC,somtGetNextGlobalDefinition)
	(this);
}


/*
 * Reintroduce inherited methods
 */

/* initializer method: somDefaultInit */
void   somDefaultInit(som3InitCtrl* ctrl)
{
/*
 *  A default initializer for a SOM object. Passing a null ctrl
 *  indicates to the receiver that its class is the class of the
 *  object being initialized, whereby the initializer will determine
 *  an appropriate control structure.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMObject,somDefaultInit)
	(this,ctrl);
}


/* method: somDestruct */
void   somDestruct(octet doFree, 
		som3DestructCtrl* ctrl)
{
/*
 *  The default destructor for a SOM object. A nonzero <doFree>
 *  indicates that the object storage should be freed by the
 *  object's class (via somDeallocate) after uninitialization.
 *  As with somDefaultInit, a null ctrl can be passed.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMObject,somDestruct)
	(this,doFree,ctrl);
}


/* initializer method: somDefaultCopyInit */
void   somDefaultCopyInit(som3InitCtrl* ctrl, 
		SOMObject* fromObj)
{
/*
 *  A default copy constructor. Use this to make copies of objects for
 *  calling methods with "by-value" argument semantics.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMObject,somDefaultCopyInit)
	(this,ctrl,fromObj);
}


/* method: somDefaultAssign */
SOMTEmitC*  somDefaultAssign(som3AssignCtrl* ctrl, 
		SOMObject* fromObj)
{
/*
 *  A default assignment operator. Use this to "assign" the state of one
 *  object to another.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somDefaultAssign)
	(this,ctrl,fromObj);
}


/* initializer method: somDefaultConstCopyInit */
void   somDefaultConstCopyInit(som3InitCtrl* ctrl, 
		SOMObject* fromObj)
{
/*
 *  A default copy constructor that uses a const fromObj.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMObject,somDefaultConstCopyInit)
	(this,ctrl,fromObj);
}


/* initializer method: somDefaultVCopyInit */
void   somDefaultVCopyInit(som3InitCtrl* ctrl, 
		SOMObject* fromObj)
{
/*
 *  A default copy constructor that uses a volatile fromObj.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMObject,somDefaultVCopyInit)
	(this,ctrl,fromObj);
}


/* initializer method: somDefaultConstVCopyInit */
void   somDefaultConstVCopyInit(som3InitCtrl* ctrl, 
		SOMObject* fromObj)
{
/*
 *  A default copy constructor that uses a const volatile fromObj.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMObject,somDefaultConstVCopyInit)
	(this,ctrl,fromObj);
}


/* method: somDefaultConstAssign */
SOMTEmitC*  somDefaultConstAssign(som3AssignCtrl* ctrl, 
		SOMObject* fromObj)
{
/*
 *  A default assignment operator that uses a const fromObj.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somDefaultConstAssign)
	(this,ctrl,fromObj);
}


/* method: somDefaultVAssign */
SOMTEmitC*  somDefaultVAssign(som3AssignCtrl* ctrl, 
		SOMObject* fromObj)
{
/*
 *  A default assignment operator that uses a volatile fromObj.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somDefaultVAssign)
	(this,ctrl,fromObj);
}


/* method: somDefaultConstVAssign */
SOMTEmitC*  somDefaultConstVAssign(som3AssignCtrl* ctrl, 
		SOMObject* fromObj)
{
/*
 *  A default assignment operator that uses a const volatile fromObj.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somDefaultConstVAssign)
	(this,ctrl,fromObj);
}


/* method: somInit */
void   somInit()
{
/*
 *  Obsolete but still supported. Override somDefaultInit instead of somInit.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMObject,somInit)
	(this);
}


/* method: somFree */
void   somFree()
{
/*
 *  Use as directed by framework implementations.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMObject,somFree)
	(this);
}


/* method: somUninit */
void   somUninit()
{
/*
 *  Obsolete but still supported. Override somDestruct instead of somUninit.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMObject,somUninit)
	(this);
}


/* method: somGetClass */
SOMClass*   somGetClass()
{
/*
 *  Return the receiver's class.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somGetClass)
	(this);
}


/* method: somGetClassName */
string   somGetClassName()
{
/*
 *  Return the name of the receiver's class.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somGetClassName)
	(this);
}


/* method: somGetSize */
long   somGetSize()
{
/*
 *  Return the size of the receiver.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somGetSize)
	(this);
}


/* method: somIsA */
boolean   somIsA(SOMClass* aClassObj)
{
/*
 *  Returns 1 (true) if the receiver responds to methods
 *  introduced by <aClassObj>, and 0 (false) otherwise.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somIsA)
	(this,aClassObj);
}


/* method: somIsInstanceOf */
boolean   somIsInstanceOf(SOMClass* aClassObj)
{
/*
 *  Returns 1 (true) if the receiver is an instance of
 *  <aClassObj> and 0 (false) otherwise.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somIsInstanceOf)
	(this,aClassObj);
}


/* method: somRespondsTo */
boolean   somRespondsTo(somId mId)
{
/*
 *  Returns 1 (true) if the indicated method can be invoked
 *  on the receiver and 0 (false) otherwise.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somRespondsTo)
	(this,mId);
}


/* va_list method: somDispatch */

/*
 *  This method provides a generic, class-specific dispatch mechanism.
 *  It accepts as input <retValue> a pointer to the memory area to be
 *  loaded with the result of dispatching the method indicated by
 *  <methodId> using the arguments in <ap>. <ap> contains the object
 *  on which the method is to be invoked as the first argument.
 */
/* the va_list invocation form */
boolean   SOMTEmitC_somDispatch(somToken* retValue, 
		somId methodId, 
		va_list ap)
{return SOM_ResolveD(this,SOMTEmitC,SOMObject,somDispatch)
	(this,retValue,methodId,ap);
}

/* the varargs invocation form */
boolean   somDispatch(somToken* retValue, 
		somId methodId, 
		...)
{
/*
 *  This method provides a generic, class-specific dispatch mechanism.
 *  It accepts as input <retValue> a pointer to the memory area to be
 *  loaded with the result of dispatching the method indicated by
 *  <methodId> using the arguments in <ap>. <ap> contains the object
 *  on which the method is to be invoked as the first argument.
 */
   va_list ap;
   va_start(ap, methodId);
   boolean __somResult = 
      SOM_ResolveD(this,SOMTEmitC,SOMObject,somDispatch)
	(this,retValue,methodId,ap);
   va_end(ap);
   return __somResult;
}


/* va_list method: somClassDispatch */

/*
 *  Like somDispatch, but method resolution for static methods is done
 *  according to the clsObj instance method table.
 */
/* the va_list invocation form */
boolean   SOMTEmitC_somClassDispatch(SOMClass* clsObj, 
		somToken* retValue, 
		somId methodId, 
		va_list ap)
{return SOM_ResolveD(this,SOMTEmitC,SOMObject,somClassDispatch)
	(this,clsObj,retValue,methodId,ap);
}

/* the varargs invocation form */
boolean   somClassDispatch(SOMClass* clsObj, 
		somToken* retValue, 
		somId methodId, 
		...)
{
/*
 *  Like somDispatch, but method resolution for static methods is done
 *  according to the clsObj instance method table.
 */
   va_list ap;
   va_start(ap, methodId);
   boolean __somResult = 
      SOM_ResolveD(this,SOMTEmitC,SOMObject,somClassDispatch)
	(this,clsObj,retValue,methodId,ap);
   va_end(ap);
   return __somResult;
}


/* method: somCastObj */
boolean   somCastObj(SOMClass* cls)
{
/*
 *  cast the receiving object to cls (which must be an ancestor of the
 *  objects true class. Returns true on success.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somCastObj)
	(this,cls);
}


/* method: somResetObj */
boolean   somResetObj()
{
/*
 *  reset an object to its true class. Returns true always.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somResetObj)
	(this);
}


/* va_list method: somDispatchV */

/*
 *  Obsolete. Use somDispatch instead.
 */
/* the va_list invocation form */
void   SOMTEmitC_somDispatchV(somId methodId, 
		somId descriptor, 
		va_list ap)
{   SOM_ResolveD(this,SOMTEmitC,SOMObject,somDispatchV)
	(this,methodId,descriptor,ap);
}

/* the varargs invocation form */
void   somDispatchV(somId methodId, 
		somId descriptor, 
		...)
{
/*
 *  Obsolete. Use somDispatch instead.
 */
   va_list ap;
   va_start(ap, descriptor);
   SOM_ResolveD(this,SOMTEmitC,SOMObject,somDispatchV)
	(this,methodId,descriptor,ap);
   va_end(ap);
}


/* va_list method: somDispatchL */

/*
 *  Obsolete. Use somDispatch instead.
 */
/* the va_list invocation form */
long   SOMTEmitC_somDispatchL(somId methodId, 
		somId descriptor, 
		va_list ap)
{return SOM_ResolveD(this,SOMTEmitC,SOMObject,somDispatchL)
	(this,methodId,descriptor,ap);
}

/* the varargs invocation form */
long   somDispatchL(somId methodId, 
		somId descriptor, 
		...)
{
/*
 *  Obsolete. Use somDispatch instead.
 */
   va_list ap;
   va_start(ap, descriptor);
   long __somResult = 
      SOM_ResolveD(this,SOMTEmitC,SOMObject,somDispatchL)
	(this,methodId,descriptor,ap);
   va_end(ap);
   return __somResult;
}


/* va_list method: somDispatchA */

/*
 *  Obsolete. Use somDispatch instead.
 */
/* the va_list invocation form */
void*   SOMTEmitC_somDispatchA(somId methodId, 
		somId descriptor, 
		va_list ap)
{return SOM_ResolveD(this,SOMTEmitC,SOMObject,somDispatchA)
	(this,methodId,descriptor,ap);
}

/* the varargs invocation form */
void*   somDispatchA(somId methodId, 
		somId descriptor, 
		...)
{
/*
 *  Obsolete. Use somDispatch instead.
 */
   va_list ap;
   va_start(ap, descriptor);
   void* __somResult = 
      SOM_ResolveD(this,SOMTEmitC,SOMObject,somDispatchA)
	(this,methodId,descriptor,ap);
   va_end(ap);
   return __somResult;
}


/* va_list method: somDispatchD */

/*
 *  Obsolete. Use somDispatch instead.
 */
/* the va_list invocation form */
double   SOMTEmitC_somDispatchD(somId methodId, 
		somId descriptor, 
		va_list ap)
{return SOM_ResolveD(this,SOMTEmitC,SOMObject,somDispatchD)
	(this,methodId,descriptor,ap);
}

/* the varargs invocation form */
double   somDispatchD(somId methodId, 
		somId descriptor, 
		...)
{
/*
 *  Obsolete. Use somDispatch instead.
 */
   va_list ap;
   va_start(ap, descriptor);
   double __somResult = 
      SOM_ResolveD(this,SOMTEmitC,SOMObject,somDispatchD)
	(this,methodId,descriptor,ap);
   va_end(ap);
   return __somResult;
}


/* method: somPrintSelf */
SOMObject*   somPrintSelf()
{
/*
 *  Uses <SOMOutCharRoutine> to write a brief string with identifying
 *  information about this object.  The default implementation just gives
 *  the object's class name and its address in memory.
 *  <self> is returned.
 */
   return SOM_ResolveD(this,SOMTEmitC,SOMObject,somPrintSelf)
	(this);
}


/* method: somDumpSelf */
void   somDumpSelf(long level)
{
/*
 *  Uses <SOMOutCharRoutine> to write a detailed description of this object
 *  and its current state.
 * 
 *  <level> indicates the nesting level for describing compound objects
 *  it must be greater than or equal to zero.  All lines in the
 *  description will be preceeded by <2*level> spaces.
 * 
 *  This routine only actually writes the data that concerns the object
 *  as a whole, such as class, and uses <somDumpSelfInt> to describe
 *  the object's current state.  This approach allows readable
 *  descriptions of compound objects to be constructed.
 * 
 *  Generally it is not necessary to override this method, if it is
 *  overriden it generally must be completely replaced.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMObject,somDumpSelf)
	(this,level);
}


/* method: somDumpSelfInt */
void   somDumpSelfInt(long level)
{
/*
 *  Uses <SOMOutCharRoutine> to write in the current state of this object.
 *  Generally this method will need to be overridden.  When overriding
 *  it, begin by calling the parent class form of this method and then
 *  write in a description of your class's instance data. This will
 *  result in a description of all the object's instance data going
 *  from its root ancestor class to its specific class.
 */
   SOM_ResolveD(this,SOMTEmitC,SOMObject,somDumpSelfInt)
	(this,level);
}



};   /* SOMTEmitC */



#endif       /* SOM_SOMTEmitC_xh */
